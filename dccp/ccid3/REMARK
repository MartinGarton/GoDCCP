* Convert all data types to dimension types
* What is the dimension of loss.go's invLossRate?

SLOW-START:

   (Section 5, Other Congestion Control Mechanisms)
   The sender starts in a slow-start phase, roughly doubling its allowed
   sending rate each round-trip time.  The slow-start phase is ended by
   the receiver's report of a data packet drop or mark, after which the
   sender uses the loss event rate to calculate its allowed sending
   rate.

RTT ESTIMATE*

   When a new RTT estimate is calculated (upon feedback packet arrival),
   update the timeout interval:

     RTO = max(4*R, 2*s/X)

NOFEEDBACK*

   If the sender hasn't received a feedback packet from the receiver when the nofeedback timer
   expires, then the sender halves its allowed sending rate. The allowed sending rate is never reduced
   below one packet per 64 seconds.

RATE

   If the sender never receives a feedback packet from the receiver, and
   as a consequence never gets to set the allowed sending rate to one
   packet per RTT, then the sending rate is left at its initial rate of
   one packet per second, with the nofeedback timer expiring after two
   seconds. The allowed sending rate is halved each time the nofeedback
   timer expires. 

   The allowed sending rate can be at most twice the rate received at the 
   receiver in the last round-trip time.

   [RFC5348, 4.3]  Update the allowed sending rate as follows.  This procedure uses
       the variables t_mbi and recv_limit:

Definition of a data-limited interval:
   We define a sender as data-limited any time it is not sending as much
   as it is allowed to send.  We define an interval as a 'data-limited
   interval' if the sender was data-limited over the *entire* interval;

IDLE AND APPLICATION LIMITED PERIODS

   (5.1) The allowed sending rate is never reduced to less than the [RFC3390]
   initial sending rate as the result of an idle period.  If the allowed
   sending rate is less than the initial sending rate upon entry to the
   idle period, then it will still be less than the initial sending rate
   when the idle period is exited.  However, if the allowed sending rate
   is greater than or equal to the initial sending rate upon entry to
   the idle period, then it should not be reduced below the initial
   sending rate no matter how long the idle period lasts.

EQUATION

                                s
   X_Bps = ----------------------------------------------------------
           R*sqrt(2*b*p/3) + (t_RTO * (3*sqrt(3*b*p/8)*p*(1+32*p^2)))

      X_Bps is TCP's average transmit rate in bytes per second.  (X_Bps
      is the same as X_calc in RFC 3448.)

      s is the segment size in bytes (excluding IP and transport
      protocol headers). [Size of one packet's payload, not counting headers.]

      R is the round-trip time in seconds.

      p is the loss event rate, between 0 and 1.0, of the number of loss
      events as a fraction of the number of packets transmitted.

      t_RTO is the TCP retransmission timeout value in seconds.

      b is the maximum number of packets acknowledged by a single TCP
      acknowledgement.

   Implementations SHOULD set t_RTO = 4*R. Implementations
   MAY also set t_RTO to max(4*R, one second), to match the recommended
   minimum of one second on the RTO [RFC2988].

   With t_RTO=4*R and b=1, the throughput equation for X_Bps, the TCP
   sending rate in bytes per second, can be simplified as:

                                s
   X_Bps = -----------------------------------------------
           R * (sqrt(2*p/3) + 12*sqrt(3*p/8)*p*(1+32*p^2))

===========================================================================================

* How does the sender's strober behave in data limited periods when the application
is not calling it for a long while? We don't want a burst of sends!

* test evolveInterval
* test loss event rate
* test receive rate
* test rttReceiver

===========================================================================================

* Ask Eddie 
	* Why wouldn't the receiver just send the loss rate instead of the interval history?

* Measure RTT based on CCVal and Timestamp opts and print head-to-head

* Add backup RTT calculation in receiver based on Timestamps

* A lot of calls to time.Nanoseconds() could be sped up by passing around the current time as an
argument

* Fix for circular arithmetic everywhere where SeqNo and AckNo are involved: loss.go, etc.

————— FEATURES NOT CURRENTLY SUPPORTED —————

* TimestampEcho option and RTT estimates based on it
* Data Dropped Option
* Slow Receiver Option

————— DEVIATIONS FROM DCCP —————
